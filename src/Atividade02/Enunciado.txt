N√∫meros complexos

Objetivo: 
Praticar o projeto de classes

C√≥digo pr√©vio
Temos dois arquivos:

Complexo.java: Inicialmente vazia, onde voc√™ ir√° implementar a classe Complexo

Main.java: Voc√™ pode usar essa classe para testar a classe. H√° um trecho de c√≥digo comentado exemplificando o uso da classe Complexo. Voc√™ pode descomentar e modificar esse trecho para testar a classe.

Restri√ß√µes:
N√£o √© necess√°rio nem permitido utilizar m√©todos pr√©-definidos da biblioteca-padr√£o de Java (por exemplo, da classe Math). Exceto pela classe java.util.Locale. Todas as opera√ß√µes podem ser feitas com os operadores aritm√©ticos usuais.

Defini√ß√£o do problema:
Um n√∫mero complexo √© um n√∫mero que pode ser expresso na forma ùëé + ùëèùëñ, onde ùëé e ùëè s√£o n√∫meros reais e ùëñ √© a unidade imagin√°ria, que satisfaz i*i = ‚àí1.

O que fazer:
Arquivo-base: Complexo.java

Propriedades: A classe deve apresentar duas propriedades, uma representando a parte real e outra representando a parte imagin√°ria do n√∫mero complexo. Ambas as propriedades devem ser do tipo double.

M√©todos: A classe deve implementar m√©todos para as opera√ß√µes a seguir. As assinaturas dos m√©todos devem corresponder ao que √© especificado no diagrama UML (i.e. mesmo nome, mesmo tipo de argumentos e mesmo tipo de retorno).

Construtor: Inicializa a parte real e imagin√°ria do n√∫mero complexo. Exemplo:

  Complexo c = new Complexo(1, 2); // c = 1 + 2i

Soma: Recebe um n√∫mero complexo como argumento e retorna um novo n√∫mero complexo que √© a soma do n√∫mero complexo atual com o n√∫mero complexo passado como argumento. Exemplo:

  Complexo c1 = new Complexo(1, 2); // c1 = 1 + 2i
  Complexo c2 = new Complexo(3, 4); // c2 = 3 + 4i

  Complexo c3 = c1.adiciona(c2); // c3 = 4 + 6i

Subtra√ß√£o: Recebe um n√∫mero complexo como argumento e retorna um novo n√∫mero complexo que √© a subtra√ß√£o do n√∫mero complexo atual com o n√∫mero complexo passado como argumento. Exemplo:

  Complexo c1 = new Complexo(1, 2); // c1 = 1 + 2i
  Complexo c2 = new Complexo(3, 4); // c2 = 3 + 4i

  Complexo c3 = c1.subtrai(c2); // c3 = -2 - 2i

Multiplica√ß√£o: Recebe um n√∫mero complexo como argumento e retorna um novo n√∫mero complexo que √© a multiplica√ß√£o do n√∫mero complexo atual com o n√∫mero complexo passado como argumento. Exemplo:

  Complexo c1 = new Complexo(1, 2); // c1 = 1 + 2i
  Complexo c2 = new Complexo(3, 4); // c2 = 3 + 4i

  Complexo c3 = c1.multiplica(c2); // c3 = -5 + 10i

Divis√£o: Recebe um n√∫mero complexo como argumento e retorna um novo n√∫mero complexo que √© a divis√£o do n√∫mero complexo atual com o n√∫mero complexo passado como argumento. Exemplo:

  Complexo c1 = new Complexo(1, 2); // c1 = 1 + 2i
  Complexo c2 = new Complexo(3, 4); // c2 = 3 + 4i

  Complexo c3 = c1.divide(c2); // c3 = 0.44 + 0.08i

Convers√£o para string: Retorna uma String que representa do n√∫mero complexo na forma ùëé + ùëèùëñ. Os valores reais devem ser exibidos com duas casas decimais.

Dica: voc√™ pode usar o m√©todo String.format() para essa opera√ß√£o. Ela opera de modo similar ao m√©todo printf, mas retorna uma String ao inv√©s de imprimir na sa√≠da padr√£o.

Exemplo:

  Complexo c = new Complexo(1, 2); // c = 1 + 2i

  System.out.println(c.converteParaString()); // imprime "1.00 + 2.00i"

Alerta: Note que, para simplificar a constru√ß√£o da String, no caso de n√∫meros negativos a parte imagin√°ria deve ser precedida por um sinal de menos, mantendo o sinal de mais entre a parte real e a imagin√°ria. Por exemplo, o n√∫mero complexo ‚àí1 ‚àí 2i deve ser representado como -1.00 + -2.00i.