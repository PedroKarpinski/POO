IntroduÃ§Ã£o Ã  programaÃ§Ã£o em Java

Objetivo:
Familiarizar-se com as principais construÃ§Ãµes sintÃ¡ticas da linguagem Java.

Praticar a construÃ§Ã£o de algoritmos envolvendo nÃºmeros e strings.

CÃ³digo prÃ©vio
O arquivo Main.java contÃ©m trÃªs mÃ©todos estÃ¡ticos que devem ser implementados:

public static double sqrt(double n, double epsilon)

Calcula a raiz quadrada de n com precisÃ£o de epsilon casas decimais.

public static boolean isPerfectNumber(long number)

Verifica se number Ã© um nÃºmero perfeito.

public static String encrypt(String message, int key)

Encripta a mensagem message com a cifra de CÃ©sar, utilizando a chave key.

public static String decrypt(String message, int key)

Desencripta a mensagem message com a cifra de CÃ©sar, utilizando a chave key.

RestriÃ§Ãµes
NÃ£o Ã© permitido usar a biblioteca java.lang.Math para cÃ¡lculos matemÃ¡ticos. Caso seja necessÃ¡rio, implemente as funÃ§Ãµes matemÃ¡ticas manualmente, pois sÃ£o simples de serem implementadas.

Enunciados
AproximaÃ§Ã£o de raiz quadrada

O mÃ©todo babilÃ´nico para aproximaÃ§Ã£o da raiz quadrada de um nÃºmero Ã© dado pela fÃ³rmula xn+1 = 1/2 (xn + n/xn), onde:

ğ‘¥ğ‘› Ã© a aproximaÃ§Ã£o atual da raiz quadrada de ğ‘›.

ğ‘¥ğ‘›+1 Ã© a prÃ³xima aproximaÃ§Ã£o da raiz quadrada de ğ‘›.

O processo Ã© repetido atÃ© que a diferenÃ§a entre ğ‘¥ğ‘›+1 e ğ‘¥ğ‘› seja menor que um valor ğœ–, que representa a quantidade de casas decimais de precisÃ£o desejada. Por exemplo, se ğœ– = 0.001, a aproximaÃ§Ã£o serÃ¡ considerada correta se a diferenÃ§a absoluta entre ğ‘¥ğ‘›+1 e ğ‘¥ğ‘› for menor que 0.001. Na primeira iteraÃ§Ã£o, Ã© preciso escolher um valor inicial para ğ‘¥0, ou melhor, fazer um â€œchuteâ€ inicial. Um valor comum Ã© ğ‘¥0 = ğ‘›/2. 

Implemente o mÃ©todo estÃ¡tico sqrt que calcula a raiz quadrada de um nÃºmero n com precisÃ£o de epsilon casas decimais. O mÃ©todo deve retornar a raiz quadrada de n com a precisÃ£o desejada.

RestriÃ§Ãµes. Assuma que os testes sempre fornecerÃ£o valores inteiros positivos para n.

Teste de nÃºmero perfeito
Um nÃºmero perfeito Ã© um inteiro positivo que Ã© igual Ã  soma de seus divisores positivos, excluindo ele mesmo. Por exemplo, 6 Ã© um nÃºmero perfeito pois 1+2+3=6. Implemente o mÃ©todo estÃ¡tico isPerfectNumber que verifica se um nÃºmero number Ã© um nÃºmero perfeito. O mÃ©todo deve retornar true se number for um nÃºmero perfeito e false caso contrÃ¡rio.

Cifra de CÃ©sar
A cifra de CÃ©sar Ã© um mÃ©todo de criptografia ancestral que consiste em substituir cada letra de uma mensagem por outra letra do alfabeto, deslocada um nÃºmero fixo de posiÃ§Ãµes, considerando a ordem natural das letras do alfabeto. Os deslocamentos, a princÃ­pio, podem ocorrer em qualquer direÃ§Ã£o, mas para simplificar, consideraremos apenas deslocamentos para a direita. Por exemplo, com uma chave de deslocamento de 3 posiÃ§Ãµes, a letra â€™aâ€™ seria substituÃ­da por â€™dâ€™, â€™bâ€™ por â€™eâ€™, â€™câ€™ por â€™fâ€™, e assim por diante. Ã‰ importante perceber que o deslocamentos sÃ£o circulares, ou seja, a letra â€™zâ€™ seria substituÃ­da por â€™câ€™.

Implemente os seguintes mÃ©todos:

O mÃ©todo encrypt que encripta uma mensagem message com a cifra de CÃ©sar, utilizando a chave key. O mÃ©todo deve retornar a mensagem encriptada.

Exemplo: encrypt("hello", 3) deve retornar "khoor".

O mÃ©todo decrypt que desencripta uma mensagem message com a cifra de CÃ©sar, utilizando a chave key. O mÃ©todo deve retornar a mensagem desencriptada.

Exemplo: decrypt("khoor", 3) deve retornar "hello".

RestriÃ§Ãµes. Considere que a mensagem a ser encriptada Ã© composta apenas por letras minÃºsculas do alfabeto, e.g. a-z, sem acentos e sem espaÃ§os.